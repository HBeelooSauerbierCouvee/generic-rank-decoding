/* check heuristic 2 in BWW25

*/
load "tools.mgm";

q := 2;
m := 61;
n := 57;
k := 44;
r := 7; 

fq  := GF(q);
fqm<w> := ext<fq | m>;
printf "\nInstance parameters\n(q,m,n,k,r,rGV)=(%o,%o,%o,%o,%o,%o)\n",q,m,n,k,r,rankGV(q,m,n,k);

a := 1;
h := 5; 
printf "(a,h)=(%o,%o)\n",a,h;

assert a le k;
assert h le r-1;

// assume successful zero-reduction step with parameter a, reduce (n,k) to (n-a,k-a)
n := n-a;
k := k-a;
printf "\nInstance parameters after zero-reduction\n(q,m,n-a,k-a,r)=(%o,%o,%o,%o,%o)\n",q,m,n,k,r;
printf "\nInstance parameters after zero- and subsupport-reduction\n(q,m,n-a-h,k-a,r-h)=(%o,%o,%o,%o,%o)\n",q,m,n-h,k,r-h;

// repeat N times trial: use zero-reduced parameters (q,m,n,k,r) -- perform subsupport-reduction with h -- solve MM equations --  check solution
N := 10;
for i in [1..N] do
	printf "\nTrial %o\n",i;
	
	// generate an R-DP instance with (unique) solution for zero-reduced parameters, BEFORE subsupport-reduction
	G,y,e := RandomRankSyndromeInstance(n,k,r,fqm,fq: verb := 0 );
	
	// calculate rowsupport (only used to generate successful subsupport-reduction subspace S)
	Emat,Cmat := RankSupport(e,fqm,fq);
	rowsupp := LinearCode(Cmat);
    	
    // create subsupport-reduced instance, repeat if one of the conditions fails
    repeat
	    conditionFailed := false;
	    	
	    // create h-dim supsupport S contained in rowsupport
	    // even though attacker does not have access to rowsupport,  
	    // random S is contained in rowsupport with success probability q^{-h(n-r)}
	    S := LinearCode( VectorSpace(fq,n) ! 0);
		if h ne 0 then
			repeat
		    	S := S + LinearCode(Random(rowsupp));
		    until Dimension(S) eq h;
		end if;
		// from here onward, rowsupport and e are not used to compute solution
		
		// compute PI matrix with S = ker(PI)
		PI := Transpose(ParityCheckMatrix(S));
		assert Random(S)*PI eq 0;
		PI := ChangeRing(PI,fqm);
		assert RankWeight(e*PI,fqm,fq) eq r-h;
		
		// apply subsupport-reduction to G, obtain Gprime in standardform 
		Cprime := LinearCode(G*PI);
		if Cprime ne StandardForm(Cprime) then
			conditionFailed := true;
		end if;
		Gprime := GeneratorMatrix(Cprime);
		
		// apply subsupport-reduction to y, obtain normalized yprime with first k positions 0 
		ypi := y*PI;
		ypi_new := ypi - Vector([ypi[j] : j in [1..k]])*Gprime;
		yn := Normalize(ypi_new);
		ind := Index(ElementToSequence(yn),1);
        assert ind ne 0;
		if ind ne k+1 then
	    	conditionFailed := true;
		end if;
		normalizationFactor := ypi_new[ind];
		yprime := ypi_new/normalizationFactor;
		
	until conditionFailed eq false;
	 
	assert ColumnSubmatrix(Gprime,[1..k]) eq IdentityMatrix(fqm,k) and {yprime[i] : i in [1..k]} eq {0} and yprime[k+1] eq 1;
	
	// create parity-check matrix of reduced code Cprime
	Hprime := Transpose(GeneratorMatrix(Dual(Cprime)));
	
	assert (yprime-(e/normalizationFactor)*PI)*Hprime eq 0;
	
	// create MaxMinors system M, and compute rank, number of eqs and number of vars
	printf "#Eq's = m*Binomial(n-h-k-1,r-h) = %o\n", m*Binomial(n-h-k-1,r-h);
	printf "#Var's = Binomial(n-a-h,r-h)-1 = %o\n", Binomial(n-h,r-h)-1;
	M := MaxMinorsMatrix(Gprime, yprime, r-h, fqm, fq);
	Mrank := Rank(M);
	printf "Rank(M) = %o\n",Mrank;
	printf "Rank(M) = min(#eq's, #var's)?: %o\n", Mrank eq Min(m*Binomial(n-h-k-1,r-h),Binomial(n-h,r-h)-1);
	
	// check that the solution is the good one if we can solve
	if Mrank eq Ncols(M)-1 then
		// solve for rank (r-h) error and obtain scaled solution e_hat
		e_hat := MaxMinorsSolve(M, Gprime, yprime, r-h);
	
		// compute scalar relating e_hat to original solution e*PI, check if e*PI is found
		scalar := normalizationFactor*(yprime*Hprime)[1]/(e_hat*Hprime)[1];
		printf "Original solution found: %o\n", (e*PI eq scalar*e_hat); 
	end if;

	   
end for;
