/* check Heuristic 2 in 
https://eprint.iacr.org/2025/1303
*/
load "tools.mgm";




function MyRandomRankSyndromeInstance(n,k,r,A,fqm,fq:verb:=0, fact1:=true, seed:=[0,0])
    if seed[1] ne 0 then SetSeed(seed[1],seed[2]);end if;
    a,b := GetSeed();
    if verb ge 1 then printf "\nSeed=%o,%o",a,b;end if;
    
    
    e   := RandomVectorofWeight(n,r,fqm,fq);
    assert RankWeight(e,fqm,fq) eq r;
    
     
    Emat,Cmat := RankSupport(e,fqm,fq);
    
    D := Dual(LinearCode(Cmat));
    
    R := LinearCode( VectorSpace(fqm,n) ! 0);
    
    
    if A ne 0 then
    	repeat
    	    repeat
    	    	new_r := Random(D);
    	    until new_r ne 0;
    	    R := R + LinearCode(ChangeRing(new_r,fqm));
    	until Dimension(R) eq A;
    end if;
    
    C := RandomLinearCode(fqm,n,k);
    
    D := Dual(C) + R;  // D has gen H / R
    
    
    C := Dual(D);
    
    new_k := k-A;
    
    k := new_k;
    
    if Dimension(C) ne new_k then
    	print "incorrect dimension";
    end if;
    
    
    
    if fact1 then
	C := StandardForm(C);
    end if;
    G := GeneratorMatrix(C);
    
    y :=  Random(VectorSpace(fqm,k)) * G + e;
    if fact1 then
	y := y - Vector([y[i] : i in [1..k]])*G;
	yn := Normalize(y);
	i := Index(ElementToSequence(yn),1);
        // if r <= rankGV then y should not be 0
        assert i ne 0;
	e := e/y[i];
	y := y/y[i];
	// up to permutation of columns, assume y[k+1]=1
	if i ne k+1 then
	    if verb ge 1 then printf "\nPermutation i=%o k+1=%o",i,k+1;end if;
	    p := Sym(n)!(k+1,i);
	    C := C^p;
	    y := y^p;
	    G := GeneratorMatrix(C);
	    e := e^p;
	end if;
    end if;
    assert ColumnSubmatrix(G,[1..k]) eq IdentityMatrix(fqm,k) and {y[i] : i in [1..k]} eq {0} and y[k+1] eq 1;
    assert  (y-e)*Transpose(GeneratorMatrix(Dual(LinearCode(G)))) eq 0;
    return G,y,e;
end function;





for q in [2..2] do
print "q=",q;
fq  := GF(q);
for m in [20..20] do
print "m=",m;
fqm<w> := ext<fq | m>;


A := 1;
print "a'=",A;

for n in [20..20] do
    print "n=",n;

    for k in [15..15] do
   	print "k=",k;
    	gv := rankGV(q,m,n,k);
    	print "gv=",gv;
    
	for r in [2..2] do
	    print "r=",r;
	    
	    counter := 0;
	    high_rank_counter := 0;
	    max_rank_counter := 0;
	   
	    predicted_rank := m*Binomial(n-k-1,r) + Binomial(n,r) - Binomial(n-A,r); 
	    variables := Binomial(n,r)-1;
	    print "Predicted:", predicted_rank, " Variables:", variables;
	   
	    	    
	    for i in [1..2000] do
	    counter := counter + 1;
	    printf "\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\bCounter:%o", counter; 
	    
	    // generate a RD instance with a solution
	    G,y,e := MyRandomRankSyndromeInstance(n,k,r,A,fqm,fq: verb := 0 );
	    new_k := k-A;
	    
	    M := MaxMinorsMatrix(G,y,r,fqm,fq);
	    rankM := Rank(M);
	   
	    if rankM gt predicted_rank then
	       print "\n\nrank M =", rankM, " Predicted:", predicted_rank, " Variables:", variables; 
     	       high_rank_counter := high_rank_counter + 1;
     	       print high_rank_counter, max_rank_counter;
	    end if;
	    
	    
	    if rankM eq Min(variables, m*Binomial(n-k+A-1,r)-(m-1)*Binomial(A,r)) then
	    	print "Maximum rank";
	    	max_rank_counter := max_rank_counter + 1;
	    	print high_rank_counter, max_rank_counter;
	    end if;

	    if rankM eq variables then
		E := MaxMinorsSolve(M,G,y,r);
	        Hy := ParityCheckMatrix(LinearCode(G)+LinearCode(y));
	        assert (RankWeight(E,fqm,fq) le r)  and (E ne 0) and E*Transpose(Hy) eq 0;
	        
	        if LinearCode(e) eq LinearCode(E) then
	           print "Original solution found (up to scalar)";
	           print  e,E,"";
	        end if;	
	   
	    end if;
		
	end for;
	
	print "\n",high_rank_counter, max_rank_counter;
	
	end for;
    end for;
end for;
end for;

end for;

print "done";
